[

## 1\. 操作系统

#### 1.1 Linux里如何查看一个想知道的进程？

 **参考回答**

 **查看进程运行状态的指令** ：ps命令。“ **ps -aux | grep PID** ”，用来查看某PID进程状态

 **答案解析**

    
    
     //ps使用示例 //显示当前所有进程   ps -A   //与grep联用查找某进程   ps -aux | grep apache    //查看进程运行状态、查看内存使用情况的指令均可使用top指令。 top

#### 1.2 Linux里如何查看带有关键字的日志文件？

 **参考回答**

  1.  **cat 路径/文件名 | grep 关键词**

    
    
     # 返回test.log中包含http的所有行 cat test.log | grep "http"

  1.  **grep -i 关键词 路径/文件名** （与方法一效果相同，不同写法而已）

    
    
    # 返回test.log中包含http的所有行(-i忽略大小写） grep -i "http" ./test.log 

#### 1.3 说说你对grep命令的了解？

 **参考回答**

grep 命令。强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。

grep
的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

 **答案解析**

    
    
     1. //参数   2. -A n --after-context显示匹配字符后n行   3. -B n --before-context显示匹配字符前n行   4. -C n --context 显示匹配字符前后n行   5. -c --count 计算符合样式的列数   6. -i 忽略大小写   7. -l 只列出文件内容符合指定的样式的文件名称   8. -f 从文件中读取关键词   9. -n 显示匹配内容的所在文件中行数   10. -R 递归查找文件夹   11.    12. //grep 的规则表达式:   13. ^       #锚定行的开始 如：'^grep'匹配所有以grep开头的行。    14. $       #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。    15. .       #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。     16. *       #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。   17. .*      #一起用代表任意字符。     18. []      #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    19. [^]     #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。     20. \(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。      21. \<      #锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。   22. \>      #锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。   23. x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    24. x\{m,\} #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。     25. x\{m,n\}#重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。     26. \w      #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。     27. \W      #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。     28. \b      #单词锁定符，如: '\bgrep\b'只匹配grep。    //实例： 1. //查找指定进程   2. ps -ef | grep svn   3.    4. //查找指定进程个数   5. ps -ef | grep svn -c   6.    7. //从文件中读取关键词   8. cat test1.txt | grep -f key.log   9.    10. //显示包含 ed 或者 at 字符的内容行   11. grep -E 'ed|at' test.txt  

#### 1.4 Linux修改主机名的命令是什么？

 **参考回答**

  1. 如果只需要临时更改主机名，可以使用hostname命令。
    
        sudo hostname <new-hostname> # 例如： sudo hostname myDebian #myDebian为修改名

  2. 如果想永久改变主机名，可以使用hostnamectl命令
    
        sudo hostnamectl set-hostname myDebian #myDebian为修改名

#### 1.5 Linux开机自动执行命令如何实现？

 **参考回答**

  1.  **方法 #1 - 使用 cron 任务**

除了常用格式（分 / 时 / 日 / 月 / 周）外，cron 调度器还支持 @reboot
指令。这个指令后面的参数是脚本（启动时要执行的那个脚本）的绝对路径。

然而，这种方法需要注意两点：

a) cron 守护进程必须处于运行状态（通常情况下都会运行），同时

b) 脚本或 crontab 文件必须包含需要的环境变量。

  2.  **方法 #2 - 使用 /etc/rc.d/rc.local**

这个方法对于 systemd-based 发行版 Linux 同样有效。不过，使用这个方法，需要授予 /etc/rc.d/rc.local 文件执行权限：

    
        # chmod +x /etc/rc.d/rc.local

然后在这个文件底部添加脚本。

#### 1.6 Linux查看内存的命令是什么？

 **参考回答**

 **查看内存使用情况的指令** ： **free命令** 。“ **free -m** ”，命令查看内存使用情况。

查看进程运行状态、查看内存使用情况的指令均可使用 **top指令** 。

 **答案解析**

  1.  **free命令**

Linux free命令用于 **显示内存状态** 。

free指令会显示内存的使用情况， **包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。**

参数如下：

    
        -b 以Byte为单位显示内存使用情况。 -k 以KB为单位显示内存使用情况。 -m 以MB为单位显示内存使用情况。 -h 以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：         B = bytes         K = kilos         M = megas         G = gigas         T = teras -o 不显示缓冲区调节列。 -s<间隔秒数> 持续观察内存使用状况。 -t 显示内存总和列。 -V 显示版本信息。

实例：显示内存使用情况

    
        # free //显示内存使用信息total used free shared buffers cachedMem: 254772 184568 70204 0 5692 89892-/+ buffers/cache: 88984 165788Swap: 524280 65116 459164

  2.  **top命令**

 **top** 命令。 **显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645696413538/2215040162017B8FD7FF8E78B49D038C)

**前五行是当前系统情况整体的统计信息区。**

    1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：

00:12:54 — 当前系统时间

up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

21users — 当前有1个用户登录系统

load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load
average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

    2. 第二行，Tasks — 任务（进程），具体信息说明如下：

系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

    3. 第三行，cpu状态信息，具体属性说明如下：

0.2%us — 用户空间占用CPU的百分比。

0.2% sy — 内核空间占用CPU的百分比。

0.0% ni — 改变过优先级的进程占用CPU的百分比

99.5% id — 空闲CPU百分比

0.0% wa — IO等待占用CPU的百分比

0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比

0.0% si — 软中断（Software Interrupts）占用CPU的百分比

    4. 第四行，内存状态，具体信息如下：

2017552 total — 物理内存总量

720188 used — 使用中的内存总量

197916 free — 空闲内存总量

1099448 cached — 缓存的总量

    5. 第五行，swap交换分区信息，具体信息说明如下：

998396 total — 交换区总量

989936 free — 空闲交换区总量

8460 used — 使用的交换区总量

1044136 cached — 缓冲的交换区总量

#### 1.7 free命令有哪些选项？

 **参考回答**

Linux free命令用于 **显示内存状态** 。

free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。

参数如下：

    
    
    -b 　以Byte为单位显示内存使用情况。-k 　以KB为单位显示内存使用情况。-m 　以MB为单位显示内存使用情况。-h 　以合适的单位显示内存使用情况，最大为三位数，自动计算对应的单位值。单位有：        B = bytes        K = kilos        M = megas        G = gigas        T = teras-o 　不显示缓冲区调节列。-s<间隔秒数> 　持续观察内存使用状况。-t 　显示内存总和列。-V 　显示版本信息。

 **答案解析**

实例：显示内存使用情况

    
    
    # free //显示内存使用信息total used free shared buffers cachedMem: 254772 184568 70204 0 5692 89892-/+ buffers/cache: 88984 165788Swap: 524280 65116 459164

#### 1.8 Linux中压缩文件的命令是什么？

 **参考回答**

Linux中压缩文件与解压文件的命令有： **tar命令、gz命令、bz2命令、compress命令、zip命令、unzip命令** 。

 **答案解析**

  1.  **tar 命令详解**

Linux tar（英文全拼：tape archive ）命令用于备份文件。

tar 是用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件。

    
        //命令格式：tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ][-b <区块数目>][-C <目的目录>][-f <备份文件>][-F <Script文件>][-K <文件>][-L <媒体容量>][-N <日期时间>][-T <范本文件>][-V <卷册名称>][-X <范本文件>][-<设备编号><存储密度>][--after-date=<日期时间>][--atime-preserve][--backuup=<备份方式>][--checkpoint][--concatenate][--confirmation][--delete][--exclude=<范本样式>][--force-local][--group=<群组名称>][--help][--ignore-failed-read][--new-volume-script=<Script文件>][--newer-mtime][--no-recursion][--null][--numeric-owner][--owner=<用户名称>][--posix][--erve][--preserve-order][--preserve-permissions][--record-size=<区块数目>][--recursive-unlink][--remove-files][--rsh-command=<执行指令>][--same-owner][--suffix=<备份字尾字符串>][--totals][--use-compress-program=<执行指令>][--version][--volno-file=<编号文件>][文件或目录...]    //常用参数：//必要参数有如下：-A 新增压缩文件到已存在的压缩-c 建立新的压缩文件-d 记录文件的差别-r 添加文件到已经压缩的文件-u 添加改变了和现有的文件到已经存在的压缩文件-x 从压缩的文件中提取文件-t 显示压缩文件的内容-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖-W 确认压缩文件的正确性    //实例//1.压缩tar -cf hhh.tar hhh       //打包 hhh 文件为 hhh.tartar -jcf hhh.tar.bz2 hhh  //压缩打包 hhh 文件为 hhh.tar.bz2tar -czf hhh.tar.gz hhh   //压缩 hhh 文件为 hhh.tar.gztar -tzvf test.tar.gz     //列出压缩文件内容    //2.解压文件  tar -tzvf test.tar.gz 

  2. **gz命令详解**

Linux gzip命令用于压缩文件。

gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出".gz"的扩展名。

    
        //命令格式：gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][文件...] 或 gzip [-acdfhlLnNqrtvV][-S &lt;压缩字尾字符串&gt;][-&lt;压缩效率&gt;][--best/fast][目录]    //常用参数：-a或--ascii 　使用ASCII文字模式。-c或--stdout或--to-stdout 　把压缩后的文件输出到标准输出设备，不去更动原始文件。-d或--decompress或----uncompress 　解开压缩文件。-f或--force 　强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。-h或--help 　在线帮助。-l或--list 　列出压缩文件的相关信息。-L或--license 　显示版本与版权信息。-n或--no-name 　压缩文件时，不保存原来的文件名称及时间戳记。-N或--name 　压缩文件时，保存原来的文件名称及时间戳记。-q或--quiet 　不显示警告信息。-r或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。-S<压缩字尾字符串>或----suffix<压缩字尾字符串> 　更改压缩字尾字符串。-t或--test 　测试压缩文件是否正确无误。-v或--verbose 　显示指令执行过程。-V或--version 　显示版本信息。-<压缩效率> 　压缩效率是一个介于1－9的数值，预设值为"6"，指定愈大的数值，压缩效率就会愈高。--best 　此参数的效果和指定"-9"参数相同。--fast 　此参数的效果和指定"-1"参数相同。    //实例//1.压缩gzip *            //压缩目录下的所有文件    //2.解压文件  gzip -dv *        //解压文件，并列出详细信息   

  3. **bz2命令详解**

bzip2(选项)（参数）：用于创建和管理.bz2格式的压缩包。

    
        //命令格式：bzip2 源文件       //压缩不保留源文件bzip2 -k 源文件    //压缩保留源文件//注意 bzip2 命令不能解压目录//常用参数：-c 将压缩与解压缩的结果送到标准输出-d 执行解压缩-f 在压缩或解压缩时，若输出文件与现有文件名相同，预设不会覆盖现有文件；使用该选项，可覆盖文件-k 在压缩或解压缩后，会删除原是文件；若要保留原是文件，使用该选项-v 压缩或解压缩文件时，显示详细的信息-z 强制执行压缩    //实例//1.压缩bzip2 源文件       //压缩不保留源文件bzip2 -k 源文件    //压缩保留源文件    //2.解压文件  bzip2 -d 源文件   //解压缩 -k 保留压缩文件bunzip2  源文件   //解压缩 -k 保留压缩文件      

  4. **compress命令详解**

Linux compress命令是一个相当古老的 unix 档案压缩指令，压缩后的档案会加上一个 .Z 延伸档名以区别未压缩的档案，压缩后的档案可以以
uncompress 解压。若要将数个档案压成一个压缩档，必须先将档案 tar 起来再压缩。由于 gzip 可以产生更理想的压缩比例，一般人多已改用
gzip 为档案压缩工具。

    
        //命令格式：compress [-dfvcV] [-b maxbits] [file ...] //常用参数：    -c 输出结果至标准输出设备（一般指荧幕）-f 强迫写入档案，若目的档已经存在，则会被覆盖 (force)-v 将程序执行的讯息印在荧幕上 (verbose)-b 设定共同字串数的上限，以位元计算，可以设定的值为 9 至 16 bits 。由于值越大，能使用的共同字串就 越多，压缩比例就越大，所以一般使用预设值 16 bits (bits)-d 将压缩档解压缩-V 列出版本讯息        //实例//1.压缩compress -f source.dat   //将 source.dat 压缩成 source.dat.Z ，若 source.dat.Z 已经存在，内容则会被压缩档覆盖。        //2.解压文件  compress -d source.dat   //将 source.dat.Z 解压成 source.dat ，若档案已经存在，使用者按 y 以确定覆盖档案，若使用 -df 程序则会自动覆盖档案。 

  5. **zip 命令详解**
    
        //命令格式：zip [-AcdDfFghjJKlLmoqrSTuvVwXyz$][-b <工作目录>][-ll][-n <字尾字符串>][-t <日期时间>][-<压缩效率>][压缩文件][文件...][-i <范本样式>][-x <范本样式>]    //常用参数：-m 将文件压缩并加入压缩文件后，删除原始文件，即把文件移到压缩文件中。-o 以压缩文件内拥有最新更改时间的文件为准，将压缩文件的更改时间设成和该文件相同。-q 不显示指令执行过程。-r 递归处理，将指定目录下的所有文件和子目录一并处理。-x<范本样式> 压缩时排除符合条件的文件。    //实例：//将 /home/html/ 这个目录下所有文件和文件夹打包为当前目录下的 html.zip：zip -q -r html.zip /home/html    //如果在我们在 /home/html 目录下，可以执行以下命令：zip -q -r html.zip *    //从压缩文件 cp.zip 中删除文件 a.czip -dv cp.zip a.c

  6.  **unzip 命令详解**

Linux unzip命令用于解压缩zip文件

unzip为.zip压缩文件的解压缩程序。

    
        //命令格式：unzip [-cflptuvz][-agCjLMnoqsVX][-P <密码>][.zip文件][文件][-d <目录>][-x <文件>] 或 unzip [-Z]    //常用参数：    -c 将解压缩的结果显示到屏幕上，并对字符做适当的转换。-f 更新现有的文件。-l 显示压缩文件内所包含的文件。-p 与-c参数类似，会将解压缩的结果显示到屏幕上，但不会执行任何的转换。-t 检查压缩文件是否正确。-u 与-f参数类似，但是除了更新现有的文件外，也会将压缩文件中的其他文件解压缩到目录中。-v 执行是时显示详细的信息。-z 仅显示压缩文件的备注文字。-a 对文本文件进行必要的字符转换。-b 不要对文本文件进行字符转换。-C 压缩文件中的文件名称区分大小写。-j 不处理压缩文件中原有的目录路径。-L 将压缩文件中的全部文件名改为小写。-M 将输出结果送到more程序处理。-n 解压缩时不要覆盖原有的文件。-o 不必先询问用户，unzip执行后覆盖原有文件。-P<密码> 使用zip的密码选项。-q 执行时不显示任何信息。-s 将文件名中的空白字符转换为底线字符。-V 保留VMS的文件版本信息。-X 解压缩时同时回存文件原来的UID/GID。[.zip文件] 指定.zip压缩文件。[文件] 指定要处理.zip压缩文件中的哪些文件。-d<目录> 指定文件解压缩后所要存储的目录。-x<文件> 指定不要处理.zip压缩文件中的哪些文件。-Z unzip -Z等于执行zipinfo指令。    //实例unzip text.zip   //将压缩文件text.zip在指定目录/tmp下解压缩，如果已有相同的文件存在，要求unzip命令不覆盖原先的文件。    unzip -n text.zip -d /tmp  //查看压缩文件目录，但不解压。

#### 1.9 Linux查询连接数的命令是什么？

 **参考回答**

  1.  **netstat**

  2.     //示例查看Web服务器（Nginx Apache）的并发请求数及其TCP连接状态：netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'解释:返回结果示例： LAST_ACK 5   (正在等待处理的请求数) SYN_RECV 30 ESTABLISHED 1597 (正常数据传输状态) FIN_WAIT1 51 FIN_WAIT2 504 TIME_WAIT 1057 (处理完毕，等待超时结束的请求数)  状态：描述 CLOSED：无连接是活动的或正在进行 LISTEN：服务器在等待进入呼叫 SYN_RECV：一个连接请求已经到达，等待确认 SYN_SENT：应用已经开始，打开一个连接 ESTABLISHED：正常数据传输状态 FIN_WAIT1：应用说它已经完成 FIN_WAIT2：另一边已同意释放 ITMED_WAIT：等待所有分组死掉 CLOSING：两边同时尝试关闭 TIME_WAIT：另一边已初始化一个释放 LAST_ACK：等待所有分组死掉

 **答案解析**

无。

#### 1.10 Linux中top命令有哪些参数？

 **参考回答**

 **top** 命令。显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等

 **参数** ：

    
    
    -d 指定每两次屏幕信息刷新之间的时间间隔。当然用户可以使用s交互命令来改变之。 -p 通过指定监控进程ID来仅仅监控某个进程的状态。 -q 该选项将使top没有任何延迟的进行刷新。如果调用程序有超级用户权限，那么top将以尽可能高的优先级运行。 -S 指定累计模式 -s 使top命令在安全模式中运行。这将去除交互命令所带来的潜在危险。 -i 使top不显示任何闲置或者僵死进程。 -c 显示整个命令行而不只是显示命令名 

**答案解析**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645696437695/09E6123299C01A32D45AED87B0CA101F)

**前五行是当前系统情况整体的统计信息区。**

  1. 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：

00:12:54 — 当前系统时间

up ？days, 4:49 — 系统已经运行了？天4小时49分钟（在这期间系统没有重启过）

21users — 当前有1个用户登录系统

load average: 0.06, 0.02, 0.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。load
average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。

  2. 第二行，Tasks — 任务（进程），具体信息说明如下：

系统现在共有256个进程，其中处于运行中的有1个，177个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。

  3. 第三行，cpu状态信息，具体属性说明如下：

0.2%us — 用户空间占用CPU的百分比。

0.2% sy — 内核空间占用CPU的百分比。

0.0% ni — 改变过优先级的进程占用CPU的百分比

99.5% id — 空闲CPU百分比

0.0% wa — IO等待占用CPU的百分比

0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比

0.0% si — 软中断（Software Interrupts）占用CPU的百分比

  4. 第四行，内存状态，具体信息如下：

2017552 total — 物理内存总量

720188 used — 使用中的内存总量

197916 free — 空闲内存总量

1099448 cached — 缓存的总量

  5. 第五行，swap交换分区信息，具体信息说明如下：

998396 total — 交换区总量

989936 free — 空闲交换区总量

8460 used — 使用的交换区总量

1044136 cached — 缓冲的交换区总量

#### 1.11 Linux中，如何通过端口查进程，如何通过进程查端口？

 **参考回答**

  1.  **linux下通过进程名查看其占用端口** ： （1）先查看进程pid
    
        ps -ef | grep 进程名

（2）通过pid查看占用端口

    
        netstat -nap | grep 进程pid

  2.  **linux通过端口查看进程** ：
    
        netstat -nap | grep 端口号

#### 1.12 请你说说ping命令？

 **参考回答**

Linux ping命令用于检测主机。

 **执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。**

 **答案解析**

语法：

    
    
    ping [-dfnqrRv][-c<完成次数>][-i<间隔秒数>][-I<网络界面>][-l<前置载入>][-p<范本样式>][-s<数据包大小>][-t<存活数值>][主机名称或IP地址]

参数说明：

    
    
    -d 使用Socket的SO_DEBUG功能。-c<完成次数> 设置完成要求回应的次数。-f 极限检测。-i<间隔秒数> 指定收发信息的间隔时间。-I<网络界面> 使用指定的网络接口送出数据包。-l<前置载入> 设置在送出要求信息之前，先行发出的数据包。-n 只输出数值。-p<范本样式> 设置填满数据包的范本样式。-q 不显示指令执行过程，开头和结尾的相关信息除外。-r 忽略普通的Routing Table，直接将数据包送到远端主机上。-R 记录路由过程。-s<数据包大小> 设置数据包的大小。-t<存活数值> 设置存活数值TTL的大小。-v 详细显示指令的执行过程。

实例：

    
    
    检测是否与主机连通# ping www.w3cschool.cc //ping主机PING aries.m.alikunlun.com (114.80.174.110) 56(84) bytes of data.64 bytes from 114.80.174.110: icmp_seq=1 ttl=64 time=0.025 ms64 bytes from 114.80.174.110: icmp_seq=2 ttl=64 time=0.036 ms64 bytes from 114.80.174.110: icmp_seq=3 ttl=64 time=0.034 ms64 bytes from 114.80.174.110: icmp_seq=4 ttl=64 time=0.034 ms64 bytes from 114.80.174.110: icmp_seq=5 ttl=64 time=0.028 ms64 bytes from 114.80.174.110: icmp_seq=6 ttl=64 time=0.028 ms64 bytes from 114.80.174.110: icmp_seq=7 ttl=64 time=0.034 ms64 bytes from 114.80.174.110: icmp_seq=8 ttl=64 time=0.034 ms64 bytes from 114.80.174.110: icmp_seq=9 ttl=64 time=0.036 ms64 bytes from 114.80.174.110: icmp_seq=10 ttl=64 time=0.041 ms--- aries.m.alikunlun.com ping statistics ---10 packets transmitted, 30 received, 0% packet loss, time 29246msrtt min/avg/max/mdev = 0.021/0.035/0.078/0.011 ms//需要手动终止Ctrl+C指定接收包的次数# ping -c 2 www.w3cschool.ccPING aries.m.alikunlun.com (114.80.174.120) 56(84) bytes of data.64 bytes from 114.80.174.120: icmp_seq=1 ttl=54 time=6.18 ms64 bytes from 114.80.174.120: icmp_seq=2 ttl=54 time=15.4 ms--- aries.m.alikunlun.com ping statistics ---2 packets transmitted, 2 received, 0% packet loss, time 1016msrtt min/avg/max/mdev = 6.185/10.824/15.464/4.640 ms//收到两次包后，自动退出多参数使用# ping -i 3 -s 1024 -t 255 g.cn //ping主机PING g.cn (203.208.37.104) 1024(1052) bytes of data.1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=0 ttl=243 time=62.5 ms1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=1 ttl=243 time=63.9 ms1032 bytes from bg-in-f104.1e100.net (203.208.37.104): icmp_seq=2 ttl=243 time=61.9 ms--- g.cn ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 6001msrtt min/avg/max/mdev = 61.959/62.843/63.984/0.894 ms, pipe 2[root@linux ~]# //-i 3 发送周期为 3秒 -s 设置发送包的大小 -t 设置TTL值为 255

#### 1.13 什么是协程？

 **参考回答**

 **协程** ：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

 **答案解析**

  1.  **线程与协程的区别：**

（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

（3）一个线程可以有多个协程。

  2.  **协程的优势：**

（1） **协程调用跟切换比线程效率高** ：协程执行效率极高。协程不需要多线程的锁机制，可以不加锁的访问全局变量，所以上下文的切换非常快。

（2） **协程占用内存少** ：执行协程只需要极少的栈内存（大概是4～5KB），而默认情况下，线程栈的大小为1MB。

（3） **切换开销更少** ：协程直接操作栈基本没有内核切换的开销，所以切换开销比线程少。

#### 1.14 为什么协程比线程切换的开销小？

 **参考回答**

（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的 **切换非常快** ，切换开销比线程更小。

（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。 **避免了加锁解锁的开销。**

####  1.15 线程和进程的区别？

 **参考回答**

（1）一个线程从属于一个进程；一个进程可以包含多个线程。

（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。

（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。

（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。

（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。

（7）通信方式不一样。

（8）进程适应于多核、多机分布；线程适用于多核

]

