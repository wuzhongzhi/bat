[

#### 1.40 介绍一下HTTPS的流程。

 **参考回答**

**HTTPS在传输的过程中会涉及到三个密钥：**
服务器端的公钥和私钥，用来进行非对称加密；客户端生成的随机密钥，用来进行对称加密。一个HTTPS请求实际上包含了两次HTTP传输，如下图可以细分为以下8步：

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697976462/458D639F0DE2FDB51585834A999C051C)

  1. 客户端向服务器发起HTTPS请求，连接到服务器的443端口

  2. 服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

  3. 服务器将自己的公钥发送给客户端。

  4. 客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

  5. 客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

  6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

  7. 然后服务器将加密后的密文发送给客户端。

  8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

 **答案解析**

无

#### 1.41 介绍一下HTTP的失败码。

 **参考回答**

HTTP的错误码包含 **客户端错误4XX** 和 **服务端错误5XX** ，两种错误分别如下：

  1. 客户端错误 4XX 

这类的状态码是适用于客户端似乎有错误的情况。除了响应给HEAD请求外，服务器应该包含一个包括错误情况描述的实体，和它是暂时的还是永久性的。这些状态码适用于任何请求方法。用户代理应该展示所有包含的实体给用户。

如果客户端正在发送数据，使用TCP的服务器应该在服务器关闭输出链接时，仔细确保客户端确认收到包含响应的数据包（receipt of the
packet(s) ） 。如果客户端继续在服务器关闭后发送数据，服务器的TCP栈将会发生一个重置包给客户端，这可能会在 HTTP
应用程序读取和解释客户端的未确认输入缓冲区（input buffers）之前将其擦除。

 **400** (错误请求) 服务器不理解请求的语法。

 **401** (未授权) 请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。

 **403** (已禁止) 服务器拒绝请求。如果在 Googlebot 尝试抓取您网站上的有效网页时显示此状态代码(您可在 Google
网站管理员工具中诊断下的网络抓取页面上看到此状态代码)，那么，这可能是您的服务器或主机拒绝 Googlebot 对其进行访问。

 **404** (未找到) 服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。

如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具”诊断”标签的 robots.txt
页上发现此状态，那么，这是正确的状态。然而，如果您有 robots.txt 文件而又发现了此状态，那么，这说明您的 robots.txt
文件可能是命名错误或位于错误的位置。(该文件应当位于顶级域名上，且应当名为 robots.txt)。

如果您在 Googlebot 尝试抓取的网址上发现此状态(位于”诊断”标签的 HTTP 错误页上)，那么，这表示 Googlebot
所追踪的可能是另一网页中的无效链接(旧链接或输入有误的链接)。

 **405** (方法禁用) 禁用请求中所指定的方法。

 **406** (不接受) 无法使用请求的内容特性来响应请求的网页。

 **407** (需要代理授权) 此状态代码与
401(未授权)类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。

 **408** (请求超时) 服务器等候请求时超时。

 **409** (冲突) 服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT
请求时可能会返回此代码，同时会提供两个请求的差异列表。

 **410** (已删除) 如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与
404(未找到)代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301
代码指定该资源的新位置。

 **411** (需要有效长度) 服务器不会接受包含无效内容长度标头字段的请求。

 **412** (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。

 **413** (请求实体过大) 服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。

 **414** (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法进行处理。

 **415** (不支持的媒体类型) 请求的格式不受请求页面的支持。

 **416** (请求范围不符合要求) 如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。

 **417** (未满足期望值) 服务器未满足”期望”请求标头字段的要求。

  2. 服务端错误 5XX

响应状态码已数字5开头，表明了这类服务器知道其错误或者无法执行请求的情况。出了响应HEAD请求外，服务器应该包括一个包含错误情况说明的实体，以及他是暂时地还是永久性的，用户代理应该将所有包含的实体展示给用户。这些响应代码适用于任何请求方法。

 **500** (服务器内部错误) 服务器遇到错误，无法完成请求。

 **501** (尚未实施) 服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。

 **502** (错误网关) 服务器作为网关或代理，从上游服务器收到了无效的响应。

 **503** (服务不可用) 目前无法使用服务器(由于超载或进行停机维护)。通常，这只是一种暂时的状态。

 **504** (网关超时) 服务器作为网关或代理，未及时从上游服务器接收请求。

 **505** (HTTP 版本不受支持) 服务器不支持请求中所使用的 HTTP 协议版本。

#### 1.42 说一说你知道的http状态码。

 **参考回答**

HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型，分类及分类描述如下表：

分类| 分类描述  
---|---  
1**| 信息，服务器收到请求，需要请求者继续执行操作  
2**| 成功，操作被成功接收并处理  
3**| 重定向，需要进一步的操作以完成请求  
4**| 客户端错误，请求包含语法错误或无法完成请求  
5**| 服务器错误，服务器在处理请求的过程中发生了错误  
  
 **各类别常见状态码** 有如下几种：

  1.  **2xx （3种）**

 **200 OK：** 表示从客户端发送给服务器的请求被正常处理并返回；

 **204 No Content：** 表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；

 **206 Patial Content：** 表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-
Range指定范围的实体内容。

  2.  **3xx （5种）**

 **301 Moved Permanently：** 永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；

 **302 Found：** 临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；

301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）

 **303 See Other：** 表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；

302与303的区别：后者明确表示客户端应当采用GET方式获取资源

 **304 Not Modified：** 表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-
Since、If-None-Match、If-Range、If-Unmodified-
Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回该状态码；

 **307 Temporary Redirect：**
临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；

  3.  **4xx （4种）**

 **400 Bad Request：** 表示请求报文中存在语法错误；

 **401 Unauthorized：** 未经许可，需要通过HTTP认证；

 **403 Forbidden：** 服务器拒绝该次访问（访问权限出现问题）

 **404 Not Found：** 表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；

  4.  **5xx （2种）**

 **500 Inter Server Error：** 表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；

 **503 Server Unavailable：** 表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；

 **答案解析**

无

#### 1.43 301和302有什么区别？

 **参考回答**

301和302的区别在于， **301重定向是永久的重定向** ，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。
**302重定向是暂时的重定向** ，搜索引擎会抓取新的内容而保存旧的网址。由于效劳器前往302代码，搜索引擎以为新的网址只是暂时的。

#### 1.44 302和304有什么区别？

 **参考回答**

302和304是网页请求的两个不同的响应状态码。302 （临时移动）表示 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
304 （未修改）表示 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

**答案解析**

无

#### 1.45 请描述一次完整的HTTP请求的过程。

 **参考回答**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645697994855/F62F028E87333BF49CEC5C06C122FB73)

DNS解析流程图

  1. 首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<http://www.zdns.cn>的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求<http://www.zdns.cn>的时候，根服务器就会返回.cn服务器的位置信息；

  2. 递归服务器拿到.cn的权威服务器地址以后，就会寻问.cn的权威服务器，知不知道<http://www.zdns.cn>的位置。这个时候.cn权威服务器查找并返回<http://zdns.cn>服务器的地址；

  3. 继续向<http://zdns.cn>的权威服务器去查询这个地址，由<http://zdns.cn>的服务器给出了地址：202.173.11.10；

  4. 最终进入http的链接，顺利访问网站；

 **补充说明**
：一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把<http://www.zdns.cn>的记录返回给客户端就可以了。

#### 1.46 什么是重定向？

 **参考回答**

**重定向(Redirect)**
就是通过各种方法将各种网络请求重新定个方向转到其它位置（如：网页重定向、域名的重定向、路由选择的变化也是对数据报文经由路径的一种重定向）。

 **答案解析**

  1. 需要重定向的情况

（1）网站调整（如改变网页目录结构）；

（2）网页被移到一个新地址；

（3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。

这几种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404
页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。

  2. 常用的重定向的方式

（1）301 redirect-----永久性转移

当用户或搜索引擎向网站服务器发出浏览请求时，服务器返回的HTTP数据流中头信息(header)中的状态码的一种，表示本网页永久性转移到另一个地址。

（2）302 redirect-----暂时性转移 (Temporarily Moved )

也被认为是 **暂时重定向** （temporary
redirect），一条对网站浏览器的指令来显示浏览器被要求显示的不同的URL，当一个网页经历过短期的URL的变化时使用。一个暂时重定向是一种服务器端的重定向，能够被搜索引擎蜘蛛正确地处理。

  3. 新旧重定向方式的区别

**302重定向是暂时的重定向** ，搜索引擎会抓取新的内容而保存旧的网址。由于效劳器前往302代码，搜索引擎以为新的网址只是暂时的；

**301重定向是永久的重定向** ，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。

  4. 为什么302 重定向和网址劫持有关联

从网址A 做一个302 重定向到网址B 时，主机服务器的隐含意思是网址A
随时有可能改主意，重新显示本身的内容或转向其他的地方。大部分的搜索引擎在大部分情况下，当收到302
重定向时，一般只要去抓取目标网址就可以了，也就是说网址B。如果搜索引擎在遇到302 转向时，百分之百的都抓取目标网址B 的话，就不用担心网址URL
劫持了。问题就在于，有的时候搜索引擎，尤其是Google，并不能总是抓取目标网址。

比如说，有的时候A 网址很短，但是它做了一个302 重定向到B 网址，而B 网址是一个很长的乱七八糟的URL
网址，甚至还有可能包含一些问号之类的参数。很自然的，A 网址更加用户友好，而B 网址既难看，又不用户友好。这时Google
很有可能会仍然显示网址A。由于搜索引擎排名算法只是程序而不是人，在遇到302 重定向的时候，并不能像人一样的去准确判定哪一个网址更适当，这就造成了网址URL
劫持的可能性。也就是说，一个不道德的人在他自己的网址A 做一个302 重定向到你的网址B，出于某种原因， Google
搜索结果所显示的仍然是网址A，但是所用的网页内容却是你的网址B 上的内容，这种情况就叫做网址URL 劫持。你辛辛苦苦所写的内容就这样被别人偷走了。

302 重定向所造成的网址URL 劫持现象，已经存在一段时间了。不过到目前为止，似乎也没有什么更好的解决方法。在正在进行的数据中心转换中，302
重定向问题也是要被解决的目标之一。从一些搜索结果来看，网址劫持现象有所改善，但是并没有完全解决。

#### 1.47 重定向和请求转发有什么区别？

 **参考回答**

  1. 请求转发

客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。

  2. 重定向

客户发送一个请求到服务器，服务器匹配servlet，servlet处理完之后调用了sendRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端收到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。（服务器向浏览器发送一个302状态码以及一个location消息头，浏览器收到请求后会向再次根据重定向地址发出请求）

  3.  **二者区别**

（1）请求次数：重定向是浏览器向服务器发送一个请求并收到响应后再次向一个新地址发出请求，转发是服务器收到请求后为了完成响应跳转到一个新的地址；重定向至少请求两次，转发请求一次；

（2）地址栏不同：重定向地址栏会发生变化，转发地址栏不会发生变化；

（3）是否共享数据：重定向两次请求不共享数据，转发一次请求共享数据（在request级别使用信息共享，使用重定向必然出错）；

（4）跳转限制：重定向可以跳转到任意URL，转发只能跳转本站点资源；

（5）发生行为不同：重定向是客户端行为，转发是服务器端行为。

 **答案解析**

无

#### 1.48 介绍一下DNS寻址的过程。

 **参考回答**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645698014644/28D4DE3BCFF84220284A4A692BB2ECB4)

DNS解析流程图

  1. 首先客户端位置是一台电脑或手机，在打开浏览器以后，比如输入<http://www.zdns.cn>的域名，它首先是由浏览器发起一个DNS解析请求，如果本地缓存服务器中找不到结果，则首先会向根服务器查询，根服务器里面记录的都是各个顶级域所在的服务器的位置，当向根服务器请求<http://www.zdns.cn>的时候，根服务器就会返回.cn服务器的位置信息；

  2. 递归服务器拿到.cn的权威服务器地址以后，就会寻问.cn的权威服务器，知不知道<http://www.zdns.cn>的位置。这个时候.cn权威服务器查找并返回<http://zdns.cn>服务器的地址；

  3. 继续向<http://zdns.cn>的权威服务器去查询这个地址，由<http://zdns.cn>的服务器给出了地址：202.173.11.10；

  4. 最终进入http的链接，顺利访问网站；

 **补充说明**
：一旦递归服务器拿到解析记录以后，就会在本地进行缓存，如果下次客户端再请求本地的递归域名服务器相同域名的时候，就不会再这样一层一层查了，因为本地服务器里面已经有缓存了，这个时候就直接把<http://www.zdns.cn>的记录返回给客户端就可以了。

 **答案解析**

  1. 什么是DNS

DNS就是域名系统，是因特网中的一项核心服务，是用于实现域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。

  2. 域名解析结构

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645698033312/F5395EA0B6DFBE3BE2CD369BB867098C)

如上图所示，域名结构是树状结构，树的最顶端代表根服务器，根的下一层就是由我们所熟知的.com、.net、.cn等通用域和.cn、.uk等国家域组成，称为顶级域。网上注册的域名基本都是二级域名，比如<http://baidu.com>、<http://taobao.com>等等二级域名，它们基本上是归企业和运维人员管理。接下来是三级或者四级域名，这里不多赘述。总体概括来说域名是由整体到局部的机制结构。

#### 1.49 说一说你对TIME_WAIT的理解。

 **参考回答**

  1. 出现 TIME_WAIT的状态原因

TIME_WAIT状态之所以存在,是为了保证网络的可靠性。由于TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭，后发送FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留2MSL时长。如果Server端一直没有向client端发送FIN消息(调用close()
API)，那么这个CLOSE_WAIT会一直存在下去。

  2. MSL概念

其指的是报文段的最大生存时间。如果报文段在网络中活动了MSL时间，还没有被接收，那么就会被丢弃。关于MSL的大小，RFC
793协议中给出的建议是2分钟，不过Linux中，通常是半分钟。

  3. TIME_WAIT持续两个MSL的作用

首先，可靠安全地关闭TCP连接。比如网络拥塞，如果主动关闭方最后一个ACK没有被被动关闭方接收到，这时被动关闭方会对FIN进行超时重传，在这时尚未关闭的TIME_WAIT就会把这些尾巴问题处理掉，不至于对新连接及其他服务产生影响。其次，防止由于没有持续TIME_WAIT时间导致的新的TCP连接建立起来，延迟的FIN重传包会干扰新的连接。

  4. TIME_WAIT占用的资源

少量内存（大概4K）和一个文件描述符fd。

  5. TIME_WAIT关闭的危害

首先，当网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包到达后会直接影响新的TCP连接；其次，当网络情况不好时，同时没有TIME_WAIT等待时，关闭连接后无新连接，那么当接收到被动方重传或延迟的FIN包后，会给被动方回送一个RST包，可能会影响被动方其他的服务连接。

 **答案解析**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645698050364/44ADD6D4E513016FCA28EB10181126F0)

当client端传输完成数据，或者需要断开连接时：

  1. Client端发送一个FIN报文给Server端。表示要终止Client到Server这个方向的连接。通过调用close(socket) API。表示Client不再会发送数据到Server端。(但Server还能继续发给Client端)。Client状态变为FIN_WAIT_1。

  2. Server端收到FIN后，发送一个ACK报文给Client端(序号为M+1)。Server状态变为CLOSE_WAIT，Client收到序号为(M+1)的ACK后状态变为FIN_WAIT_2。Server端也发送一个FIN报文给Client端。(序号为N) 表示Server也要终止到Client端这个方向的连接。通过调用close(socket) API。Server端状态变为LAST_ACK。

  3. Client端收到报文FIN后，也发送一个ACK报文给服务器。(序号N+1)，Client状态变为TIME_WAIT。

  4. Server端收到序号为(N+1)的ACK， Server的状态变为CLOSED。

  5. 等带2MSL之后，Client的状态也变为CLOSE。

至此，一个完整的TCP连接就关闭了。

#### 1.50 TIME_WAIT、CLOSE_WAIT状态发生在哪一步？

 **参考回答**

  1.  **TIME_WAIT状态** 发生在客户端主动关闭连接时，发送最后一个ack后； **CLOSE_WAIT状态** 发生在在Sever端收到Client的FIN消息之后。

  2. 出现 TIME_WAIT的状态原因

TIME_WAIT状态之所以存在,是为了保证网络的可靠性。由于TCP连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发FIN包的一方执行的是主动关闭，后发送FIN包的一方执行的是被动关闭。主动关闭的一方会进入TIME_WAIT状态，并且在此状态停留2MSL时长。如果Server端一直没有向client端发送FIN消息(调用close()
API)，那么这个CLOSE_WAIT会一直存在下去。

  3. 出现CLOSE_WAIT的状态原因

假设最终的ACK丢失，server将重发FIN，client必须维护TCP状态信息以便可以重发最终的ACK，否则会发送RST，结果server认为发生错误。TCP实现必须可靠地终止连接的两个方向(全双工关闭)，client必须进入
TIME_WAIT 状态，因为client可能面临重发最终ACK的情形。

  4. 为什么 TIME_WAIT 状态需要保持 2MSL 这么长的时间？

如果 TIME_WAIT
状态保持时间不足够长(比如小于2MSL)，第一个连接就正常终止了。第二个拥有相同相关五元组的连接出现，而第一个连接的重复报文到达，干扰了第二个连接。TCP实现必须防止某个连接的重复报文在连接终止后出现，所以让TIME_WAIT状态保持时间足够长(2MSL)，连接相应方向上的TCP报文要么完全响应完毕，要么被丢弃。建立第二个连接的时候，不会混淆。

 **答案解析**

![](https://uploadfiles.nowcoder.com/images/20220224/4107856_1645698066180/FAAE6BAE6215C267D988957CFCF5B2A8)

当client端传输完成数据，或者需要断开连接时：

  1. Client端发送一个FIN报文给Server端。表示要终止Client到Server这个方向的连接。通过调用close(socket) API。表示Client不再会发送数据到Server端。(但Server还能继续发给Client端)。Client状态变为FIN_WAIT_1。

  2. Server端收到FIN后，发送一个ACK报文给Client端(序号为M+1)。Server状态变为CLOSE_WAIT，Client收到序号为(M+1)的ACK后状态变为FIN_WAIT_2。Server端也发送一个FIN报文给Client端。(序号为N) 表示Server也要终止到Client端这个方向的连接。通过调用close(socket) API。Server端状态变为LAST_ACK。

  3. Client端收到报文FIN后，也发送一个ACK报文给服务器。(序号N+1)，Client状态变为TIME_WAIT。

  4. Server端收到序号为(N+1)的ACK， Server的状态变为CLOSED。

  5. 等带2MSL之后，Client的状态也变为CLOSE。

至此，一个完整的TCP连接就关闭了。

#### 1.51 有大量的TIME_WAIT状态怎么办？

 **参考回答**

  1. time_wait 状态的影响

TCP 连接中，主动发起关闭连接的一端，会进入 time_wait 状态，time_wait 状态，默认会持续 2 MSL（报文的最大生存时间），一般是
2x2 mins，time_wait 状态下，TCP 连接占用的端口，无法被再次使用，TCP 端口数量，上限是 6.5w（65535，16 bit），
**大量 time_wait 状态存在，会导致新建 TCP 连接会出错，address already in use : connect异常** 。

  2.  **解决办法**

（1） **客户端** ：HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间：现在的浏览器，一般都这么进行了 。

（2） **服务器端**

a. 允许 time_wait状态的 socket 被 **重用**

b. 缩减 time_wait 时间，设置为 1 MSL（即，2 mins）

 **答案解析**

无

#### 1.52 请介绍socket通信的具体步骤。

 **参考回答**

sockets（套接字）编程有三种： **流式套接字（SOCK_STREAM），数据报套接字（SOCK_DGRAM），原始套接字（SOCK_RAW）**
；基于TCP的socket编程是采用的流式套接字。

  1. 服务器端编程的步骤

（1）加载套接字库，创建套接字(WSAStartup()/socket())；

（2）绑定套接字到一个IP地址和一个端口上(bind())；

（3）将套接字设置为监听模式等待连接请求(listen())；

（4）请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字(accept())；

（5）用返回的套接字和客户端进行通信(send()/recv())；

（6）返回，等待另一连接请求；

（7）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。

  2. 客户端编程的步骤：

（1）加载套接字库，创建套接字(WSAStartup()/socket())；

（2）向服务器发出连接请求(connect())；

（3）和服务器端进行通信(send()/recv())；

（4）关闭套接字，关闭加载的套接字库(closesocket()/WSACleanup())。

**答案解析**

    
    
     //代码实例（服务器） #include <stdio.h> #include <Winsock2.h> void main() {  WORD wVersionRequested;  WSADATA wsaData;  int err;     wVersionRequested = MAKEWORD( 1, 1 );     err = WSAStartup( wVersionRequested, &wsaData );  if ( err != 0 ) {   return;  }     if ( LOBYTE( wsaData.wVersion ) != 1 ||         HIBYTE( wsaData.wVersion ) != 1 ) {   WSACleanup( );   return;  }  SOCKET sockSrv=socket(AF_INET,SOCK_STREAM,0);    SOCKADDR_IN addrSrv;  addrSrv.sin_addr.S_un.S_addr=htonl(INADDR_ANY);  addrSrv.sin_family=AF_INET;  addrSrv.sin_port=htons(6000);     bind(sockSrv,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));    listen(sockSrv,5);    SOCKADDR_IN addrClient;  int len=sizeof(SOCKADDR);  while(1)  {   SOCKET sockConn=accept(sockSrv,(SOCKADDR*)&addrClient,&len);   char sendBuf[50];   sprintf(sendBuf,"Welcome %s to here!",inet_ntoa(addrClient.sin_addr));   send(sockConn,sendBuf,strlen(sendBuf)+1,0);   char recvBuf[50];   recv(sockConn,recvBuf,50,0);   printf("%s\n",recvBuf);   closesocket(sockConn);  }   }
    
    
    //代码实例（客户端） #include <stdio.h> #include <Winsock2.h> void main() {  WORD wVersionRequested;  WSADATA wsaData;  int err;    wVersionRequested = MAKEWORD( 1, 1 );    err = WSAStartup( wVersionRequested, &wsaData );  if ( err != 0 ) {   return;  }    if ( LOBYTE( wsaData.wVersion ) != 1 ||         HIBYTE( wsaData.wVersion ) != 1 ) {   WSACleanup( );   return;  }  SOCKET sockClient=socket(AF_INET,SOCK_STREAM,0);    SOCKADDR_IN addrSrv;  addrSrv.sin_addr.S_un.S_addr=inet_addr("127.0.0.1");  addrSrv.sin_family=AF_INET;  addrSrv.sin_port=htons(6000);  connect(sockClient,(SOCKADDR*)&addrSrv,sizeof(SOCKADDR));  send(sockClient,"hello",strlen("hello")+1,0);  char recvBuf[50];  recv(sockClient,recvBuf,50,0);  printf("%s\n",recvBuf);    closesocket(sockClient);  WSACleanup(); }

#### 1.53 服务端怎么提高处理socket连接的性能？

 **参考回答**

提高处理socket连接的性能，请遵循以下技巧：

  1. 最小化报文传输的延时。

  2. 最小化系统调用的负载。

  3. 为 Bandwidth Delay Product 调节 TCP 窗口。

  4. 动态优化 GNU/Linux TCP/IP 栈。

 **答案解析**

  1. 最小化报文传输的延时。

在通过 TCP socket 进行通信时，数据都拆分成了数据块，这样它们就可以封装到给定连接的 TCP payload（指 TCP
数据包中的有效负荷）中了。TCP payload
的大小取决于几个因素（例如最大报文长度和路径），但是这些因素在连接发起时都是已知的。为了达到最好的性能，我们的目标是使用尽可能多的可用数据来填充每个报文。当没有足够的数据来填充
payload 时（也称为最大报文段长度（maximum segment size）或 MSS），TCP 就会采用 Nagle
算法自动将一些小的缓冲区连接到一个报文段中。这样可以通过最小化所发送的报文的数量来提高应用程序的效率，并减轻整体的网络拥塞问题。

  2. 最小化系统调用的负载。

任何时候通过一个 socket 来读写数据时，都是在使用一个系统调用（system call）。这个调用（例如 read 或
write）跨越了用户空间应用程序与内核的边界。另外，在进入内核之前，该调用会通过 C 库来进入内核中的一个通用函数（system_call()）。从
system_call()中，这个调用会进入文件系统层，内核会在这儿确定正在处理的是哪种类型的设备。最后，调用会进入 socket
层，数据就是在这里进行读取或进行排队从而通过 socket 进行传输的（这涉及数据的副本）。

这个过程说明 **系统调用不仅仅是在应用程序和内核中进行操作的，而且还要经过应用程序和内核中的很多层次。**
这个过程耗费的资源很高，因此调用次数越多，通过这个调用链进行的工作所需要的时间就越长，应用程序的性能也就越低。由于我们 **无法避免这些系统调用** ，因此
**唯一的选择是最小化使用这些调用的次数** 。

  3. 为 Bandwidth Delay Product 调节 TCP 窗口。

TCP 的性能取决于几个方面的因素。两个最重要的因素是链接带宽（link bandwidth）（报文在网络上传输的速率）和 往返时间（round-trip
time） 或 RTT（发送报文与接收到另一端的响应之间的延时）。这两个值确定了称为 Bandwidth Delay Product（BDP）的内容。

给定链接带宽和 RTT 之后，就可以计算出 BDP 的值了，不过这代表什么意义呢？BDP 给出了一种简单的方法来计算理论上最优的 TCP socket
缓冲区大小（其中保存了排队等待传输和等待应用程序接收的数据）。如果缓冲区太小，那么 TCP
窗口就不能完全打开，这会对性能造成限制。如果缓冲区太大，那么宝贵的内存资源就会造成浪费。如果设置的缓冲区大小正好合适，那么就可以完全利用可用的带宽。

  4. 动态优化 GNU/Linux TCP/IP 栈。

标准的 GNU/Linux 发行版试图对各种部署情况都进行优化。这意味着标准的发行版可能并没有对现有的环境进行特殊的优化。GNU/Linux
提供了很多可调节的内核参数，可以使用这些参数为自己的操作系统进行动态配置。

#### 1.54 介绍一下流量控制和拥塞控制。

 **参考回答**

  1. 流量控制和拥塞控制定义

 **流量控制**

如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。 **流量控制** 就是让发送方慢点，要让接收方来得及接收。

 **拥塞控制**

拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

  2. 流量控制和拥塞控制区别

流量控制是 **端到端**
的控制，例如A通过网络给B发数据，A发送的太快导致B没法接收(B缓冲窗口过小或者处理过慢)，这时候的控制就是流量控制，原理是通过滑动窗口的大小改变来实现。

拥塞控制是A与B之间的网络发生堵塞导致传输过慢或者丢包，来不及传输。防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不至于过载。拥塞控制是一个
**全局性** 的过程，涉及到所有的主机、路由器，以及与降低网络性能有关的所有因素。

  3. TCP流量控制解决方法

TCP的流量控制是利用 **滑动窗口机制** 实现的，接收方在返回的数据中会包含自己的接收窗口的大小，以控制发送方的数据发送。

  4. TCP拥塞控制解决方法

TCP拥塞控制的四种算法： **慢开始、拥塞避免、快重传、快恢复。**

（1） **慢开始算法：**
当主机开始发送数据时，并不清楚网络的负载情况，所以由小到大逐渐增大拥塞窗口，每经过一个传输轮次没有出现超时就将拥塞窗口加倍。同时还需要设置一个慢开始门限，在拥塞窗口小于慢开始门限时使用慢开始算法，大于慢开始门限时，使用拥塞避免算法；

（2） **拥塞避免算法：**
在拥塞窗口大于慢开始门限时，让拥塞窗口按线性规律缓慢增长。即每经过一个传输轮次，拥塞窗口增大一个MSS最大报文段尺寸。（拥塞避免并非完全能够避免拥塞，只是使网络比较不容易出现拥塞）

（3） **快重传算法：** 使发送方今早知道发生了个别报文段丢失，并不是出现网络拥塞。

要求接受不要登塞自己发送数据时才进行捎带确认，而是立即发送确认，即使收到了失序的报文段也要立即发出对已收到报文段的重复确认。而发送方一旦受到三个连续的重读确认，就将相应的报文段立即重传。

（4） **快恢复算法：**
发送方知道只有个别报文段丢失而不是网络拥塞时，不启动慢开始算法，而是执行快恢复算法，将慢开始门限和拥塞窗口值调整为当前窗口的一半，开始执行拥塞避免算法

**答案解析**

无

#### 1.55 对路由协议是否有所了解？

 **参考回答**

有了解。

  1. 路由协议定义

**路由协议** （英语：Routing
protocol）是一种指定数据包转送方式的网上协议。Internet网络的主要节点设备是路由器，路由器通过路由表来转发接收到的数据。转发策略可以是人工指定的（通过静态路由、策略路由等方法）。在具有较小规模的网络中，人工指定转发策略没有任何问题。但是在具有较大规模的网络中（如跨国企业网络、ISP网络），如果通过人工指定转发策略，将会给网络管理员带来巨大的工作量，并且在管理、维护路由表上也变得十分困难。为了解决这个问题，动态路由协议应运而生。动态路由协议可以让路由器自动学习到其他路由器的网络，并且网络拓扑发生改变后自动更新路由表。网络管理员只需要配置动态路由协议即可，相比人工指定转发策略，工作量大大减少。

  2. 原理

路由协议通过在路由器之间共享路由信息来支持可路由协议。路由信息在相邻路由器之间传递，确保所有路由器知道到其它路由器的路径。总之，路由协议创建了路由表，描述了网络拓扑结构；路由协议与路由器，执行路由选择和数据包转发功能。

  3. 路由器的作用以及常见的路由协议

**路由协议主要运行于路由器上，路由协议是用来确定到达路径的，起到一个地图导航，负责找路的作用。**
它工作在网络层。它包括RIP，IGRP（Cisco私有协议），EIGRP（Cisco私有协议），OSPF，IS-IS，BGP。以下为这六个协议的详细说明：

（1）RIP（路由信息协议）

RIP很早就被用在Internet上，是 **最简单的路由协议** 。它是“路由信息协议（Route Information
Protocol）”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息计算自己的路由表信息。RIP是一个
**距离矢量路由协议**
，最大跳数为15跳，超过15跳的网络则认为目标网络不可达。此协议通常用在网络架构较为简单的小型网络环境。分为RIPv1和RIPv2两个版本，后者支持VLSM技术以及一系列技术上的改进。RIP的收敛速度较慢。

（2）IGRP（内部网关路由协议）

IGRP协议是“内部网关路由协议（Interior Gateway Routing
Protocol）”的缩写，由Cisco于二十世纪八十年代独立开发，属于Cisco私有协议。IGRP和RIP一样，同属距离矢量路由协议，因此在诸多方面有着相似点，如IGRP也是周期性的广播路由表，也存在最大跳数（默认为100跳，达到或超过100跳则认为目标网络不可达）。IGRP最大的特点是使用了混合度量值，同时考虑了链路的带宽、延迟、负载、MTU、可靠性5个方面来计算路由的度量值，而不像其他IGP协议单纯的考虑某一个方面来计算度量值。IGRP已经被Cisco独立开发的EIGRP协议所取代，版本号为12.3及其以上的Cisco
IOS（Internetwork Operating System）已经不支持该协议，已经罕有运行IGRP协议的网络。

（3）EIGRP（增强型内部网关路由协议）

由于IGRP协议的种种缺陷以及不足，Cisco开发了EIGRP协议（增强型内部网关路由协议）来取代IGRP协议。EIGRP属于高级距离矢量路由协议（又称混合型路由协议），继承了IGRP的混合度量值，最大特点在于引入了非等价负载均衡技术，并拥有极快的收敛速度。EIGRP协议在Cisco设备网络环境中广泛部署。

（4）OSPF（开放式最短路径优先）

OSPF协议是“开放式最短路径优先（Open Shortest Path
First）”的缩写，属于链路状态路由协议。OSPF提出了“区域（area）”的概念，每个区域中所有路由器维护着一个相同的链路状态数据库（LSDB）。区域又分为骨干区域（骨干区域的编号必须为0）和非骨干区域（非0编号区域），如果一个运行OSPF的网络只存在单一区域，则该区域可以是骨干区域或者非骨干区域。如果该网络存在多个区域，那么必须存在骨干区域，并且所有非骨干区域必须和骨干区域直接相连。OSPF利用所维护的链路状态数据库，通过最短路径优先算法（SPF算法）计算得到路由表。OSPF的收敛速度较快。由于其特有的开放性以及良好的扩展性，OSPF协议在各种网络中广泛部署。

（5）IS-IS（中间系统到中间系统）

IS-IS协议是Intermediate system to intermediate
system（中间系统到中间系统）的缩写，属于链路状态路由协议。标准IS-IS协议是由国际标准化组织制定的ISO/IEC
10589:2002所定义的，标准IS-IS不适合用于IP网络，因此IETF制定了适用于IP网络的集成化IS-IS协议（Integrated IS-
IS）。和OSPF相同，IS-IS也使用了“区域”的概念，同样也维护着一份链路状态数据库，通过最短生成树算法（SPF）计算出最佳路径。IS-
IS的收敛速度较快。集成化IS-IS协议是ISP骨干网上最常用的IGP协议。

（6）BGP（边界网关协议）

为了维护各个ISP的独立利益，标准化组织制定了ISP间的路由协议BGP。BGP是“边界网关协议（Border Gateway
Protocol）”的缩写，处理各ISP之间的路由传递。但是BGP运行在相对核心的地位，需要用户对网络的结构有相当的了解，否则可能会造成较大损失。

 **答案解析**

无

#### 1.56 直播可能需要使用到什么样的协议？

 **参考回答**

视频直播有多种协议，使用rtmp协议的就是rtmp直播。直播流就是视频流，即传递的视频数据。常见的协议有 **RTMP、RTSP、HTTP协议**
，这三个协议都属于互联网 **TCP/IP五层体系结构中应用层** 的协议。理论上这三种都可以用来做视频直播或点播。但通常来说，
**直播一般用RTMP、RTSP，而点播用HTTP。** 下面分别介绍下三者的特点。

  1. RTMP协议

（1）是流媒体协议；

（2）RTMP协议是Adobe的私有协议，未完全公开；

（3）RTMP协议一般传输的是flv，f4v格式流；

（4）RTMP一般在TCP1个通道上传输命令和数据。

  2. RTSP协议

（1）是流媒体协议；

（2）RTSP协议是共有协议，并有专门机构做维护；

（3）RTSP协议一般传输的是ts、mp4格式的流；

（4）RTSP传输一般需要2-3个通道，命令和数据通道分离。

  3. HTTP协议

（1）不是是流媒体协议；

（2）HTTP协议是共有协议，并有专门机构做维护；

（3）HTTP协议没有特定的传输流；

（4）HTTP传输一般需要2-3个通道，命令和数据通道分离。

 **答案解析**

**扩展资料**

一个完整的视频直播过程，包括 **采集、处理、编码、封装、推流、传输、转码、分发、解码、播放等** 。

  1. 采集

音频采集音频的采集过程主要通过设备将环境中的模拟信号采集成 PCM 编码的原始数据，然后编码压缩成 MP3
等格式的数据分发出去。常见的音频压缩格式有：MP3，AAC，HE-AAC，Opus，FLAC，Vorbis (Ogg)，Speex 和 AMR等。

图像采集 图像的采集过程主要由摄像头等设备拍摄成 YUV 编码的原始数据，然后经过编码压缩成 H.264
等格式的数据分发出去。常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 等。

  2. 处理

视频或者音频完成采集之后得到原始数据，为了增强一些现场效果或者加上一些额外的效果，我们一般会在将其编码压缩前进行处理。

视频：美颜、水印、路径、自定义。

音频：混音、降噪、特效、自定义。

  3. 编码

对流媒体传输来说，编码非常重要，它的编码性能、编码速度和编码压缩比会直接影响整个流媒体传输的用户体验和传输成本。

常见的视频编码器：

（1）H.264/AVC

（2）HEVC/H.265

（3）VP8

（4）VP9

（5）FFmpeg

音频编码器：Mp3, AAC等。

  4. 封装

把编码器生成的多媒体内容(视频，音频，字幕，章节信息等)混合封装在一起几种常见的封装格式：

（1）AVI 格式(后缀为 .avi)

（2）DV-AVI 格式(后缀为 .avi)

（3）QuickTime File Format 格式(后缀为 .mov)

（4）MPEG 格式(文件后缀可以是 .mpg .mpeg .mpe .dat .vob .asf .3gp .mp4等)

（5）WMV 格式(后缀为.wmv .asf)

（6）Real Video 格式(后缀为 .rm .rmvb)

（7）Flash Video 格式(后缀为 .flv)

（8）Matroska 格式(后缀为 .mkv)

（9）MPEG2-TS 格式 (后缀为 .ts)

目前，我们在流媒体传输，尤其是直播中主要采用的就是 FLV 和 MPEG2-TS 格式，分别用于 RTMP/HTTP-FLV 和 HLS 协议。

  5. 推流

推流是指使用推流工具等内容抓取软件把直播内容传输到服务器的过程。推送协议主要有三种：

（1）RTSP(Real Time Streaming Protocol)：实时流传送协议，是用来控制声音或影像的多媒体串流协议, 由Real
Networks和Netscape共同提出的;

（2）RTMP(Real Time Messaging
Protocol)：实时消息传送协议，是Adobe公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议;

（3）HLS(HTTP Live Streaming)：是苹果公司(Apple
Inc.)实现的基于HTTP的流媒体传输协议;RTMP是目前主流的流媒体传输协议，广泛用于直播领域，市面上绝大多数的直播产品都采用了这个协议。

RTMP协议基于 TCP，是一种设计用来进行实时数据通信的网络协议，主要用来在 flash/AIR 平台和支持 RTMP
协议的流媒体/交互服务器之间进行音视频和数据通信。支持该协议的软件包括 Adobe Media Server/Ultrant Media
Server/red5 等。它有三种变种：

（1）RTMP工作在TCP之上的明文协议，使用端口1935；

（2）RTMPT封装在HTTP请求之中，可穿越防火墙;

（3）RTMPS类似RTMPT，但使用的是HTTPS连接;

RTMP协议就像一个用来装数据包的容器，这些数据可以是AMF格式的数据,也可以是FLV中的视/音频数据。一个单一的连接可以通过不同的通道传输多路网络流。这些通道中的包都是按照固定大小的包传输的。

  6. 传输

推送出去的流媒体需要传输到观众，整个链路就是传输网络。

  7. 转码

视频直播播流端的码率是根据推流端决定的，即播流端的码率是与推流端的码率一致的。但是遇到以下场景会造成直播效果较差：推流端码率与播流端带宽不相匹配。当推流端码率较高而客户端带宽资源有限就会导致播放出现卡顿，而当推流端码率较低但是客户端对于直播效率要求较高时会导致播放效果较差。播放器插件需要实现多码率切换。前端播放器插件常可以设置码率切换，这就需要同一路推流可以同时提供多种码率的播流地址。因此，视频直播提供了实时转码功能对同一路推流地址同时提供多路不同码率播流地址提供服务。

  8. 分发

流媒体服务器的作用是负责直播流的发布和转播分发功能。

  9. 解码

编码器(Encoder)：压缩信号的设备或程序；

解码器(Decoder)：解压缩信号的设备或程序；

编解码器(Codec)：编解码器对。

  10. 播放器流播放主要是实现直播节目在终端上的展现。因为这里使用的传输协议是RTMP， 所以只要支持 RTMP 流协议的播放器都可以使用。

#### 1.57 谈谈单工、双工、半双工的通信方式。

 **参考回答**

  1.  **单工：** 数据传输只支持数据在一个方向上传输；在同一时间只有一方能接受或发送信息，不能实现双向通信。举例：电视，广播。

  2.  **半双工：** 半双工数据传输允许数据在两个方向上传输,但是,在某一时刻,只允许数据在一个方向上传输,它实际上是一种切换方向的单工通信；在同一时间只可以有一方接受或发送信息，可以实现双向通信。举例：对讲机。

  3.  **双工：** 全双工数据通信允许数据同时在两个方向上传输,因此,全双工通信是两个单工通信方式的结合,它要求发送设备和接收设备都有独立的接收和发送能力；在同一时间可以同时接受和发送信息，实现双向通信。举例：电话通信。

 **答案解析**

**扩展资料：**

单工、半双工和全双工是电信计算机网络中的三种通信信道。这些通信信道可以提供信息传达的途径。通信信道可以是物理传输介质或通过多路复用介质的逻辑连接。物理传输介质是指能够传播能量波的材料物质，例如数据通信中的导线。并且逻辑连接通常指电路交换连接或分组模式虚拟电路连接，例如无线电信通道。由于通信信道的帮助，信息可以无障碍地传输。

单工模式一般用在只向一个方向传输数据的场合。例如计算机与打印机之间的通信是单工模式，因为只有计算机向打印机传输数据，而没有相反方向的数据传输。还有在某些通信信道中，如单工无线发送等。

  

]

